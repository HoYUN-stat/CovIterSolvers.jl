<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · CovIterSolvers.jl</title><meta name="title" content="Home · CovIterSolvers.jl"/><meta property="og:title" content="Home · CovIterSolvers.jl"/><meta property="twitter:title" content="Home · CovIterSolvers.jl"/><meta name="description" content="Documentation for CovIterSolvers.jl."/><meta property="og:description" content="Documentation for CovIterSolvers.jl."/><meta property="twitter:description" content="Documentation for CovIterSolvers.jl."/><meta property="og:url" content="https://HoYUN-stat.github.io/CovIterSolvers.jl/"/><meta property="twitter:url" content="https://HoYUN-stat.github.io/CovIterSolvers.jl/"/><link rel="canonical" href="https://HoYUN-stat.github.io/CovIterSolvers.jl/"/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>CovIterSolvers.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#API-Reference"><span>API Reference</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="github.com/HoYUN-stat/CovIterSolvers.jl/blob/main//docs/src/index.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="CovIterSolvers.jl"><a class="docs-heading-anchor" href="#CovIterSolvers.jl">CovIterSolvers.jl</a><a id="CovIterSolvers.jl-1"></a><a class="docs-heading-anchor-permalink" href="#CovIterSolvers.jl" title="Permalink"></a></h1><p><code>CovIterSolvers.jl</code> provides a high-performance pipeline for covariance smoothing and functional principal component analysis using Krylov subspace methods.</p><h2 id="API-Reference"><a class="docs-heading-anchor" href="#API-Reference">API Reference</a><a id="API-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#API-Reference" title="Permalink"></a></h2><p>The following pages list all the functions and types available in the package.</p><ul><li><a href="#CovIterSolvers.AbstractBlockGP"><code>CovIterSolvers.AbstractBlockGP</code></a></li><li><a href="#CovIterSolvers.AbstractEstimateMethod"><code>CovIterSolvers.AbstractEstimateMethod</code></a></li><li><a href="#CovIterSolvers.AdjointBlockOuter"><code>CovIterSolvers.AdjointBlockOuter</code></a></li><li><a href="#CovIterSolvers.AdjointCovFwdTensor"><code>CovIterSolvers.AdjointCovFwdTensor</code></a></li><li><a href="#CovIterSolvers.BSplineMethod"><code>CovIterSolvers.BSplineMethod</code></a></li><li><a href="#CovIterSolvers.BlockDiagonal"><code>CovIterSolvers.BlockDiagonal</code></a></li><li><a href="#CovIterSolvers.BlockOuter"><code>CovIterSolvers.BlockOuter</code></a></li><li><a href="#CovIterSolvers.BrownianBridge"><code>CovIterSolvers.BrownianBridge</code></a></li><li><a href="#CovIterSolvers.BrownianMotion"><code>CovIterSolvers.BrownianMotion</code></a></li><li><a href="#CovIterSolvers.CovFwdTensor"><code>CovIterSolvers.CovFwdTensor</code></a></li><li><a href="#CovIterSolvers.CustomGP"><code>CovIterSolvers.CustomGP</code></a></li><li><a href="#CovIterSolvers.CustomKernel"><code>CovIterSolvers.CustomKernel</code></a></li><li><a href="#CovIterSolvers.GaussianKernel"><code>CovIterSolvers.GaussianKernel</code></a></li><li><a href="#CovIterSolvers.IntegratedBM"><code>CovIterSolvers.IntegratedBM</code></a></li><li><a href="#CovIterSolvers.LaplacianKernel"><code>CovIterSolvers.LaplacianKernel</code></a></li><li><a href="#CovIterSolvers.MaternKernel"><code>CovIterSolvers.MaternKernel</code></a></li><li><a href="#CovIterSolvers.OrnsteinUhlenbeck"><code>CovIterSolvers.OrnsteinUhlenbeck</code></a></li><li><a href="#CovIterSolvers.RBFKernelMethod"><code>CovIterSolvers.RBFKernelMethod</code></a></li><li><a href="#BlockArrays.blocksizes-Tuple{BlockDiagonal, Int64}"><code>BlockArrays.blocksizes</code></a></li><li><a href="#CovIterSolvers.block_outer-Union{Tuple{BlockArrays.AbstractBlockVector{T}}, Tuple{T}} where T"><code>CovIterSolvers.block_outer</code></a></li><li><a href="#CovIterSolvers.compute_kernel-Union{Tuple{T}, Tuple{T, GaussianKernel{T}}} where T&lt;:Real"><code>CovIterSolvers.compute_kernel</code></a></li><li><a href="#CovIterSolvers.conj_lanczos-Union{Tuple{T}, Tuple{BlockArrays.AbstractBlockVector{T}, BlockDiagonal{T, R} where R&lt;:(AbstractVector{&lt;:AbstractMatrix{T}}), BlockArrays.AbstractBlockMatrix{T}}} where T"><code>CovIterSolvers.conj_lanczos</code></a></li><li><a href="#CovIterSolvers.covariancekernel"><code>CovIterSolvers.covariancekernel</code></a></li><li><a href="#CovIterSolvers.eval_covariance-Union{Tuple{T}, Tuple{BlockArrays.BlockMatrix{T, R} where R&lt;:(AbstractMatrix{&lt;:AbstractMatrix{T}}), BlockDiagonal{T, R} where R&lt;:(AbstractVector{&lt;:AbstractMatrix{T}})}} where T"><code>CovIterSolvers.eval_covariance</code></a></li><li><a href="#CovIterSolvers.eval_fwd"><code>CovIterSolvers.eval_fwd</code></a></li><li><a href="#CovIterSolvers.fpca"><code>CovIterSolvers.fpca</code></a></li><li><a href="#CovIterSolvers.loc_grid-Tuple{Type{&lt;:Number}, Vector{Int64}}"><code>CovIterSolvers.loc_grid</code></a></li><li><a href="#CovIterSolvers.mean_fwd-Union{Tuple{T}, Tuple{BlockArrays.BlockVector{T, R} where R&lt;:(AbstractVector{&lt;:AbstractVector{T}}), BSplineMethod{T}}} where T"><code>CovIterSolvers.mean_fwd</code></a></li><li><a href="#CovIterSolvers.mean_fwd-Union{Tuple{T}, Tuple{BlockArrays.BlockVector{T, R} where R&lt;:(AbstractVector{&lt;:AbstractVector{T}}), RBFKernelMethod{T}}} where T"><code>CovIterSolvers.mean_fwd</code></a></li><li><a href="#CovIterSolvers.rand_block_diag-Tuple{Type, Vector{Int64}}"><code>CovIterSolvers.rand_block_diag</code></a></li><li><a href="#CovIterSolvers.sample_gp"><code>CovIterSolvers.sample_gp</code></a></li><li><a href="#CovIterSolvers.undef_block_diag-Tuple{Type, Vector{Int64}}"><code>CovIterSolvers.undef_block_diag</code></a></li><li><a href="#CovIterSolvers.zero_block_diag-Tuple{Type, Vector{Int64}}"><code>CovIterSolvers.zero_block_diag</code></a></li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CovIterSolvers.AbstractBlockGP" href="#CovIterSolvers.AbstractBlockGP"><code>CovIterSolvers.AbstractBlockGP</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractBlockGP{T}</code></pre><p>Abstract supertype for all Gaussian Process (GP), characterized by its covariance function.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/HoYUN-stat/CovIterSolvers.jl/blob/5aadd3383822d88d6c6ca4458831e07c2b156e6e//src/blockgaussproc.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CovIterSolvers.AbstractEstimateMethod" href="#CovIterSolvers.AbstractEstimateMethod"><code>CovIterSolvers.AbstractEstimateMethod</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractEstimateMethod{T}</code></pre><p>Supertype for all estimation methods in this package.</p><p><strong>Subtypes</strong></p><ul><li><code>BSplineMethod{T}</code>: Methods based on B-splines.</li><li><code>RBFKernelMethod{T}</code>: Methods based on Radial Basis Functions (RBF) kernels.</li></ul></div><a class="docs-sourcelink" target="_blank" href="github.com/HoYUN-stat/CovIterSolvers.jl/blob/5aadd3383822d88d6c6ca4458831e07c2b156e6e//src/estimationmethod.jl#L1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CovIterSolvers.AdjointBlockOuter" href="#CovIterSolvers.AdjointBlockOuter"><code>CovIterSolvers.AdjointBlockOuter</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AdjointBlockOuter(E, [workspace])</code></pre><p>Represents the adjoint of the <code>BlockOuter</code> operator.</p><p>This type is typically not constructed directly, but rather by taking the adjoint of a <code>BlockOuter</code> object (e.g., <code>L&#39;</code>).</p><p>The operator <code>L&#39;</code> is defined by its action on a <code>BlockDiagonal</code> matrix <code>A</code>: <code>A = L&#39;(B)</code>, where the i-th block of <code>A</code> is computed as <code>A_i = ∑ⱼ Eⱼᵢ&#39; Bⱼ Eᵢⱼ</code>.</p><p><strong>Fields</strong></p><ul><li><code>F::AbstractBlockMatrix</code>: The block matrix that defines the original operator.</li><li><code>workspace::Matrix</code>: Pre-allocated matrix to be used for intermediate calculations.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; E = BlockMatrix(rand(3, 2), [2, 1], [1, 1]);

julia&gt; L_adj = (E ⊙ E)&#39;;

julia&gt; L_adj isa AdjointBlockOuter
true</code></pre><p>See also <a href="#CovIterSolvers.BlockOuter"><code>BlockOuter</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/HoYUN-stat/CovIterSolvers.jl/blob/5aadd3383822d88d6c6ca4458831e07c2b156e6e//src/blocktensor.jl#L115-L142">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CovIterSolvers.AdjointCovFwdTensor" href="#CovIterSolvers.AdjointCovFwdTensor"><code>CovIterSolvers.AdjointCovFwdTensor</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AdjointCovFwdTensor(F, [workspace])</code></pre><p>Represents the adjoint of the <code>CovFwdTensor</code> operator.</p><p><strong>Fields</strong></p><ul><li><code>F::AbstractBlockMatrix</code>: The block matrix that defines the core of the operator.</li><li><code>workspace::Matrix</code>: Pre-allocated matrix to be used for intermediate calculations.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; F = BlockMatrix(rand(3, 2), [2, 1], [1, 1]);

julia&gt; L = CovFwdTensor(F);

julia&gt; L_adj = L&#39;;

julia&gt; L_adj isa AdjointCovFwdTensor
true

julia&gt; L_adj&#39; === L
true</code></pre><p>See also <a href="#CovIterSolvers.CovFwdTensor"><code>CovFwdTensor</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/HoYUN-stat/CovIterSolvers.jl/blob/5aadd3383822d88d6c6ca4458831e07c2b156e6e//src/blocktensor.jl#L168-L193">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CovIterSolvers.BSplineMethod" href="#CovIterSolvers.BSplineMethod"><code>CovIterSolvers.BSplineMethod</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BSplineMethod(order, knots)</code></pre><p>An estimation method that uses a B-spline basis.</p><p><strong>Arguments</strong></p><ul><li><code>order::Int</code>: The order of the B-spline (e.g., 4 for cubic B-splines).</li><li><code>knots::AbstractVector</code>: The knot vector defining the B-spline basis.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; knots = 0.0:0.1:1.0;

julia&gt; method = BSplineMethod(4, knots);

julia&gt; method.order
4</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/HoYUN-stat/CovIterSolvers.jl/blob/5aadd3383822d88d6c6ca4458831e07c2b156e6e//src/estimationmethod.jl#L28-L46">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CovIterSolvers.BlockDiagonal" href="#CovIterSolvers.BlockDiagonal"><code>CovIterSolvers.BlockDiagonal</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BlockDiagonal{T, R&lt;:(AbstractArray{&lt;:AbstractArray{T, 2}, 1})}</code></pre><p>Blocked array of square matrices of type <code>T</code> arranged in a block diagonal structure.</p><p><strong>Fields</strong></p><ul><li><code>blocks::R</code>: stores the vector of matrices of type <code>T</code> being wrapped.</li></ul><p><strong>Supertype Hierarchy</strong></p><ul><li><code>BlockDiagonal{T, R&lt;:(AbstractArray{&lt;:AbstractArray{T, 2}, 1})} &lt;: AbstractArray{T, 1} &lt;: Any</code></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [1 2; 3 4];

julia&gt; B = [5 6; 8 9];

julia&gt; bd = BlockDiagonal([A, B]);

julia&gt; bd.blocks[1]
2×2 Matrix{Int64}:
 1  2
 3  4</code></pre><p>See also <a href="#BlockArrays.blocksizes-Tuple{BlockDiagonal, Int64}"><code>blocksizes</code></a>, <a href="#CovIterSolvers.zero_block_diag-Tuple{Type, Vector{Int64}}"><code>zero_block_diag</code></a>, <a href="#CovIterSolvers.undef_block_diag-Tuple{Type, Vector{Int64}}"><code>undef_block_diag</code></a>, <a href="#CovIterSolvers.rand_block_diag-Tuple{Type, Vector{Int64}}"><code>rand_block_diag</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/HoYUN-stat/CovIterSolvers.jl/blob/5aadd3383822d88d6c6ca4458831e07c2b156e6e//src/blockdiag.jl#L1-L27">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CovIterSolvers.BlockOuter" href="#CovIterSolvers.BlockOuter"><code>CovIterSolvers.BlockOuter</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BlockOuter(E, [workspace])
E ⊙ E</code></pre><p>Represents a linear operator <code>L</code> that performs a block-wise outer product.</p><p>The operator <code>L</code> is defined by its action on a <code>BlockDiagonal</code> matrix <code>A</code>: <code>B = L(A)</code>, where the j-th block of <code>B</code> is computed as <code>B_j = ∑ᵢ Eⱼᵢ Aᵢ Eᵢⱼ&#39;</code>.</p><p>The infix operator <code>⊙</code> is an alias for the constructor <code>BlockOuter(E)</code>. It requires that both operands are the same object (e.g., <code>E ⊙ E</code>).</p><p><strong>Fields</strong></p><ul><li><code>E::AbstractBlockMatrix</code>: The block matrix that defines the operator.</li><li><code>workspace::Matrix</code>: Pre-allocated matrix to be used for intermediate calculations.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; E = BlockMatrix(rand(3, 2), [2, 1], [1, 1]);

julia&gt; L = E ⊙ E; # Element-free operator

julia&gt; L_adj = L&#39;; # Take the adjoint

julia&gt; L_adj isa AdjointBlockOuter
true</code></pre><p>See also <a href="#CovIterSolvers.AdjointBlockOuter"><code>AdjointBlockOuter</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/HoYUN-stat/CovIterSolvers.jl/blob/5aadd3383822d88d6c6ca4458831e07c2b156e6e//src/blocktensor.jl#L7-L37">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CovIterSolvers.BrownianBridge" href="#CovIterSolvers.BrownianBridge"><code>CovIterSolvers.BrownianBridge</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BrownianBridge([T=Float64])</code></pre><p>A standard Brownian Bridge process, which is a Brownian Motion conditioned to be zero at <code>t=0</code> and <code>t=1</code>.</p><p>The covariance function is <code>Σ(s, t) = min(s, t) - s * t</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; bb = BrownianBridge();

julia&gt; covariancekernel(bb, 0.2, 0.5)
0.1</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/HoYUN-stat/CovIterSolvers.jl/blob/5aadd3383822d88d6c6ca4458831e07c2b156e6e//src/blockgaussproc.jl#L26-L41">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CovIterSolvers.BrownianMotion" href="#CovIterSolvers.BrownianMotion"><code>CovIterSolvers.BrownianMotion</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BrownianMotion([T=Float64])</code></pre><p>A standard Brownian Motion / Wiener Process.</p><p>The covariance function is <code>Σ(s, t) = min(s, t)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; bm = BrownianMotion();

julia&gt; covariancekernel(bm, 0.2, 0.5)
0.2</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/HoYUN-stat/CovIterSolvers.jl/blob/5aadd3383822d88d6c6ca4458831e07c2b156e6e//src/blockgaussproc.jl#L8-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CovIterSolvers.CovFwdTensor" href="#CovIterSolvers.CovFwdTensor"><code>CovIterSolvers.CovFwdTensor</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CovFwdTensor(F, [workspace])</code></pre><p>Represents a covariance-based forward operator <code>L</code> for B-splines or RKHS.</p><p>Its action <code>L = O * (F ⊙ F) * O&#39;</code> depends on the block structure of <code>F</code>`.</p><p><strong>Fields</strong></p><ul><li><code>F::AbstractBlockMatrix</code>: The block matrix that defines the core of the operator.</li><li><code>workspace::Matrix</code>: Pre-allocated matrix to be used for intermediate calculations.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; F = BlockMatrix(rand(3, 2), [2, 1], [1, 1]);

julia&gt; L = CovFwdTensor(F);

julia&gt; L_adj = adjoint(L); # Or L&#39;

julia&gt; L_adj isa AdjointCovFwdTensor
true</code></pre><p>See also <a href="#CovIterSolvers.AdjointCovFwdTensor"><code>AdjointCovFwdTensor</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/HoYUN-stat/CovIterSolvers.jl/blob/5aadd3383822d88d6c6ca4458831e07c2b156e6e//src/blocktensor.jl#L67-L91">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CovIterSolvers.CustomGP" href="#CovIterSolvers.CustomGP"><code>CovIterSolvers.CustomGP</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CustomGP([T=Float64], Σ)</code></pre><p>A Gaussian Process defined by a user-supplied covariance function <code>Σ(s, t)</code>.</p><p><strong>Arguments</strong></p><ul><li><code>T::Type</code>: The element type of the process. Defaults to <code>Float64</code>.</li><li><code>Σ::Function</code>: A two-argument function <code>(s, t) -&gt; value</code> that defines the covariance.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; my_cov(s, t) = exp(-abs(s - t)); # Exponential covariance

julia&gt; gp = CustomGP(my_cov);

julia&gt; covariancekernel(gp, 0.2, 0.5) ≈ exp(-0.3)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/HoYUN-stat/CovIterSolvers.jl/blob/5aadd3383822d88d6c6ca4458831e07c2b156e6e//src/blockgaussproc.jl#L94-L112">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CovIterSolvers.CustomKernel" href="#CovIterSolvers.CustomKernel"><code>CovIterSolvers.CustomKernel</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CustomKernel(f, [trunc_dist=nothing])</code></pre><p>A custom Radial Basis Function (RBF) kernel defined by a user-provided function <code>f</code>.</p><p>The kernel is defined as <code>K(x, y) = f(||x - y||)</code>.</p><p><strong>Arguments</strong></p><ul><li><code>f::Function</code>: A function that takes a distance of type <code>T</code> and returns a real number.</li><li><code>trunc_dist::Union{Nothing, T}</code>: An optional truncation distance. If provided, the kernel will return zero for <code>||x - y|| &gt; trunc_dist</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; f(x) = exp(-x^2);  # Example custom kernel function

julia&gt; ck = CustomKernel(f)
CustomKernel{Float64,typeof(f)}(f, nothing)

julia&gt; ck_trunc = CustomKernel(f, 10.0)
CustomKernel{Float64,typeof(f)}(f, 10.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/HoYUN-stat/CovIterSolvers.jl/blob/5aadd3383822d88d6c6ca4458831e07c2b156e6e//src/estimationmethod.jl#L146-L168">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CovIterSolvers.GaussianKernel" href="#CovIterSolvers.GaussianKernel"><code>CovIterSolvers.GaussianKernel</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">GaussianKernel(γ, [trunc_dist=nothing])</code></pre><p>A Gaussian Radial Basis Function (RBF) kernel defined by <code>K(x, y) = exp(-γ * ||x - y||^2)</code>.</p><p><strong>Arguments</strong></p><ul><li><code>γ::Real</code>: The positive kernel parameter.</li><li><code>trunc_dist::Union{Nothing, Real}</code>: An optional truncation distance. If provided, the kernel will return zero for <code>||x - y|| &gt; trunc_dist</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; gk = GaussianKernel(0.5)
GaussianKernel{Float64}(0.5, nothing)

julia&gt; gk_trunc = GaussianKernel(0.5, 10.0)
GaussianKernel{Float64}(0.5, 10.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/HoYUN-stat/CovIterSolvers.jl/blob/5aadd3383822d88d6c6ca4458831e07c2b156e6e//src/estimationmethod.jl#L52-L70">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CovIterSolvers.IntegratedBM" href="#CovIterSolvers.IntegratedBM"><code>CovIterSolvers.IntegratedBM</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">IntegratedBM([T=Float64])</code></pre><p>An Integrated Brownian Motion process.</p><p>The covariance function is <code>Σ(s, t) = max(s,t) * min(s,t)^2 / 2 - min(s,t)^3 / 6</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ibm = IntegratedBM();

julia&gt; covariancekernel(ibm, 0.2, 0.5)
0.008666666666666668</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/HoYUN-stat/CovIterSolvers.jl/blob/5aadd3383822d88d6c6ca4458831e07c2b156e6e//src/blockgaussproc.jl#L45-L59">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CovIterSolvers.LaplacianKernel" href="#CovIterSolvers.LaplacianKernel"><code>CovIterSolvers.LaplacianKernel</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LaplacianKernel(γ, [trunc_dist=nothing])</code></pre><p>A Laplacian Radial Basis Function (RBF) kernel defined by <code>K(x, y) = exp(-γ * ||x - y||)</code>.</p><p><strong>Arguments</strong></p><ul><li><code>γ::Real</code>: The positive kernel parameter.</li><li><code>trunc_dist::Union{Nothing, Real}</code>: An optional truncation distance. If provided, the kernel will return zero for <code>||x - y|| &gt; trunc_dist</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; lk = LaplacianKernel(0.5)
LaplacianKernel{Float64}(0.5, nothing)

julia&gt; lk_trunc = LaplacianKernel(0.5, 10.0)
LaplacianKernel{Float64}(0.5, 10.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/HoYUN-stat/CovIterSolvers.jl/blob/5aadd3383822d88d6c6ca4458831e07c2b156e6e//src/estimationmethod.jl#L82-L100">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CovIterSolvers.MaternKernel" href="#CovIterSolvers.MaternKernel"><code>CovIterSolvers.MaternKernel</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MaternKernel(ν, γ, [trunc_dist=nothing])</code></pre><p>A Matern Radial Basis Function (RBF) kernel defined by <code>K(x, y) = (2^(1-ν) / Γ(ν)) * (γ * ||x - y||)^ν * K_{ν}(γ * ||x - y||)</code>, where <code>K_{ν}</code> is the modified Bessel function of the second kind.</p><p><strong>Arguments</strong></p><ul><li><code>ν::Real</code>: The smoothness parameter (ν = 1/2: Laplacian, ν → ∞: Gaussian).</li><li><code>γ::Real</code>: The positive kernel parameter.</li><li><code>trunc_dist::Union{Nothing, Real}</code>: An optional truncation distance. If provided, the kernel will return zero for <code>||x - y|| &gt; trunc_dist</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; mk = MaternKernel(1.5, 0.5)
MaternKernel{Float64}(1.5, 0.5, nothing)

julia&gt; mk_trunc = MaternKernel(1.5, 0.5, 10.0)
MaternKernel{Float64}(1.5, 0.5, 10.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/HoYUN-stat/CovIterSolvers.jl/blob/5aadd3383822d88d6c6ca4458831e07c2b156e6e//src/estimationmethod.jl#L112-L133">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CovIterSolvers.OrnsteinUhlenbeck" href="#CovIterSolvers.OrnsteinUhlenbeck"><code>CovIterSolvers.OrnsteinUhlenbeck</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">OrnsteinUhlenbeck(θ, σ)</code></pre><p>An Ornstein-Uhlenbeck process, which models a mean-reverting stochastic process.</p><p>The covariance function is <code>Σ(s, t) = (σ²/2θ) * (exp(-θ|s-t|) - exp(-θ(s+t)))</code>.</p><p><strong>Arguments</strong></p><ul><li><code>θ::Real</code>: The mean reversion rate (must be positive).</li><li><code>σ::Real</code>: The volatility parameter (must be non-negative).</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ou = OrnsteinUhlenbeck(1.0, 0.5);

julia&gt; ou.θ
1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/HoYUN-stat/CovIterSolvers.jl/blob/5aadd3383822d88d6c6ca4458831e07c2b156e6e//src/blockgaussproc.jl#L63-L81">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CovIterSolvers.RBFKernelMethod" href="#CovIterSolvers.RBFKernelMethod"><code>CovIterSolvers.RBFKernelMethod</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RBFKernelMethod{T} &lt;: AbstractEstimateMethod{T}</code></pre><p>Abstract supertype for methods based on a Radial Basis Function (RBF) kernel.</p><p>All RBF kernels define a function <code>K(x, y)</code> that depends only on the distance between <code>x</code> and <code>y</code>, i.e., <code>K(x, y) = f(||x - y||)</code>.</p><p>See also <a href="#CovIterSolvers.GaussianKernel"><code>GaussianKernel</code></a>, <a href="#CovIterSolvers.LaplacianKernel"><code>LaplacianKernel</code></a>, <a href="#CovIterSolvers.MaternKernel"><code>MaternKernel</code></a>, <a href="#CovIterSolvers.CustomKernel"><code>CustomKernel</code></a> for concrete implementations.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/HoYUN-stat/CovIterSolvers.jl/blob/5aadd3383822d88d6c6ca4458831e07c2b156e6e//src/estimationmethod.jl#L12-L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BlockArrays.blocksizes-Tuple{BlockDiagonal, Int64}" href="#BlockArrays.blocksizes-Tuple{BlockDiagonal, Int64}"><code>BlockArrays.blocksizes</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">blocksizes(D::BlockDiagonal, d::Int)</code></pre><p>Returns the sizes of the blocks in a <code>BlockDiagonal</code> matrix along the specified dimension <code>d</code>.</p><p><strong>Arguments</strong></p><ul><li><code>D::BlockDiagonal</code>: The block diagonal matrix.</li><li><code>d::Int</code>: The dimension along which to get the block sizes (1 for rows, 2 for columns).</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; block_sizes = [2, 1];

julia&gt; bd = rand_block_diag(block_sizes; seed=123);

julia&gt; blocksizes(bd, 1)
2-element Vector{Int64}:
 2
 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/HoYUN-stat/CovIterSolvers.jl/blob/5aadd3383822d88d6c6ca4458831e07c2b156e6e//src/blockdiag.jl#L254-L274">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CovIterSolvers.block_outer-Union{Tuple{BlockArrays.AbstractBlockVector{T}}, Tuple{T}} where T" href="#CovIterSolvers.block_outer-Union{Tuple{BlockArrays.AbstractBlockVector{T}}, Tuple{T}} where T"><code>CovIterSolvers.block_outer</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">block_outer(y)
y ⊙ y</code></pre><p>Computes the block-wise outer product of a <code>BlockVector</code>, returning a <code>BlockDiagonal</code> matrix.</p><p>For a <code>BlockVector</code> <code>y</code> with blocks <code>y₁, y₂, ...</code>, this function computes a <code>BlockDiagonal</code> matrix where the i-th block is the outer product <code>yᵢ * yᵢ&#39;</code>.</p><p>The infix operator <code>⊙</code> is an alias for this function. It must be used on the same object (e.g., <code>y ⊙ y</code>).</p><p><strong>Arguments</strong></p><ul><li><code>y::AbstractBlockVector</code>: The input block vector.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; v = [1.0, 2.0, 3.0];

julia&gt; y = BlockVector(v, [2, 1]);

julia&gt; (y ⊙ y).blocks[1]
2×2 Matrix{Float64}:
 1.0  2.0
 2.0  4.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/HoYUN-stat/CovIterSolvers.jl/blob/5aadd3383822d88d6c6ca4458831e07c2b156e6e//src/blockdiag.jl#L218-L243">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CovIterSolvers.compute_kernel-Union{Tuple{T}, Tuple{T, GaussianKernel{T}}} where T&lt;:Real" href="#CovIterSolvers.compute_kernel-Union{Tuple{T}, Tuple{T, GaussianKernel{T}}} where T&lt;:Real"><code>CovIterSolvers.compute_kernel</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">compute_kernel(dist, kernel)</code></pre><p>Compute the value of an RBF kernel for a given distance.</p><p>This function uses multiple dispatch to select the correct kernel formula based on the type of the <code>kernel</code> object.</p><p><strong>Arguments</strong></p><ul><li><code>dist::Real</code>: The distance between two points.</li><li><code>kernel::RBFKernelMethod</code>: The kernel object containing its parameters.</li></ul><p><strong>Returns</strong></p><ul><li>The scalar value of the kernel evaluation.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; dist = 0.4;

julia&gt; kernel = GaussianKernel(1.0);

julia&gt; compute_kernel(dist, kernel) ≈ 0.8521437889662113
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/HoYUN-stat/CovIterSolvers.jl/blob/5aadd3383822d88d6c6ca4458831e07c2b156e6e//src/blockforward.jl#L137-L161">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CovIterSolvers.conj_lanczos-Union{Tuple{T}, Tuple{BlockArrays.AbstractBlockVector{T}, BlockDiagonal{T, R} where R&lt;:(AbstractVector{&lt;:AbstractMatrix{T}}), BlockArrays.AbstractBlockMatrix{T}}} where T" href="#CovIterSolvers.conj_lanczos-Union{Tuple{T}, Tuple{BlockArrays.AbstractBlockVector{T}, BlockDiagonal{T, R} where R&lt;:(AbstractVector{&lt;:AbstractMatrix{T}}), BlockArrays.AbstractBlockMatrix{T}}} where T"><code>CovIterSolvers.conj_lanczos</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">conj_lanczos(b0, D, C; ...)</code></pre><p>Performs the C-Lanczos algorithm for the generalized eigenvalue problem <code>D*C*q = λ*q</code>.</p><p>This iterative method generates a C-orthonormal basis <code>Q</code> for the Krylov subspace and a symmetric tridiagonal matrix <code>T</code> that represents the projection of the operator <code>D*C</code> onto that subspace.</p><p><strong>Arguments</strong></p><ul><li><code>b0::AbstractBlockVector{T}</code>: The starting vector for the iteration.</li><li><code>D::BlockDiagonal{T}</code>: A block-diagonal matrix to factorize.</li><li><code>C::AbstractBlockMatrix{T}</code>: A symmetric, positive-definite matrix defining the inner product (<code>C</code>-inner product).</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>itmax::Int=100</code>: Maximum number of iterations.</li><li><code>tol::Float64=1e-8</code>: Tolerance for the C-norm of the residual to determine convergence.</li><li><code>history::Bool=false</code>: If <code>true</code>, the history of residual C-norms is stored and returned.</li><li><code>reortho_level::Symbol=:full</code>: Level of reorthogonalization. Use <code>:full</code> for numerical stability, or <code>:none</code> to observe loss of orthogonality.</li></ul><p><strong>Returns</strong></p><ul><li><code>NamedTuple</code>: A named tuple <code>(T, Q, history)</code> containing:<ul><li><code>T</code>: A <code>SymTridiagonal</code> matrix.</li><li><code>Q</code>: A matrix whose columns are the C-orthonormal Lanczos basis vectors.</li><li><code>history</code>: A vector of residual C-norms, or <code>nothing</code> if <code>history=false</code>.</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="github.com/HoYUN-stat/CovIterSolvers.jl/blob/5aadd3383822d88d6c6ca4458831e07c2b156e6e//src/conjlanczos.jl#L50-L77">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CovIterSolvers.covariancekernel" href="#CovIterSolvers.covariancekernel"><code>CovIterSolvers.covariancekernel</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">covariancekernel(process, s, t)
covariancekernel(process, s)
covariancekernel(process, loc1, loc2)
covariancekernel(process, loc)</code></pre><p>Compute the covariance for a given Gaussian Process.</p><p>This function has several methods:</p><ol><li><code>covariancekernel(process, s, t)</code>: Computes the scalar covariance between two points <code>s</code> and <code>t</code>.</li><li><code>covariancekernel(process, s)</code>: Computes the covariance of a single point <code>s</code> with itself.</li><li><code>covariancekernel(process, loc1, loc2)</code>: Computes the cross-covariance matrix between two vectors of locations.</li><li><code>covariancekernel(process, loc)</code>: Computes the full covariance matrix (Gram matrix) for a single vector of locations.</li></ol><p><strong>Arguments</strong></p><ul><li><code>process::AbstractBlockGP</code>: The Gaussian Process object defining the covariance structure.</li><li><code>s, t::Number</code>: Scalar locations.</li><li><code>loc1, loc2, loc::AbstractVector</code>: Vectors of locations.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; bm = BrownianMotion();

julia&gt; covariancekernel(bm, 0.3, 0.8) # scalar version
0.3

julia&gt; loc = [0.1, 0.5, 0.9];

julia&gt; K = covariancekernel(bm, loc) # matrix version
3×3 Matrix{Float64}:
 0.1  0.1  0.1
 0.1  0.5  0.5
 0.1  0.5  0.9</code></pre><p>See also <a href="#CovIterSolvers.sample_gp"><code>sample_gp</code></a> for generating sample paths from the GP.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/HoYUN-stat/CovIterSolvers.jl/blob/5aadd3383822d88d6c6ca4458831e07c2b156e6e//src/blockgaussproc.jl#L122-L158">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CovIterSolvers.eval_covariance-Union{Tuple{T}, Tuple{BlockArrays.BlockMatrix{T, R} where R&lt;:(AbstractMatrix{&lt;:AbstractMatrix{T}}), BlockDiagonal{T, R} where R&lt;:(AbstractVector{&lt;:AbstractMatrix{T}})}} where T" href="#CovIterSolvers.eval_covariance-Union{Tuple{T}, Tuple{BlockArrays.BlockMatrix{T, R} where R&lt;:(AbstractMatrix{&lt;:AbstractMatrix{T}}), BlockDiagonal{T, R} where R&lt;:(AbstractVector{&lt;:AbstractMatrix{T}})}} where T"><code>CovIterSolvers.eval_covariance</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">eval_covariance(E, A)</code></pre><p>Computes the covariance matrix <code>Σ = E * A * E&#39;</code>.</p><p><strong>Arguments</strong></p><ul><li><code>E::BlockMatrix{T}</code>: The forward evaluation matrix.</li><li><code>A::BlockDiagonal{T}</code>: A block-diagonal matrix, typically representing the prior covariance of the coefficients.</li></ul><p><strong>Returns</strong></p><ul><li><code>Matrix{T}</code>: The resulting dense covariance matrix <code>Σ</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; E = BlockMatrix(ones(3, 2), [3], [2]);

julia&gt; A = BlockDiagonal([[1.0 0.5; 0.5 1.0]]);

julia&gt; Σ = eval_covariance(E, A)
3×3 Matrix{Float64}:
 3.0  3.0  3.0
 3.0  3.0  3.0
 3.0  3.0  3.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/HoYUN-stat/CovIterSolvers.jl/blob/5aadd3383822d88d6c6ca4458831e07c2b156e6e//src/blockevaluation.jl#L140-L165">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CovIterSolvers.eval_fwd" href="#CovIterSolvers.eval_fwd"><code>CovIterSolvers.eval_fwd</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">eval_fwd(eval_points, myspline)
eval_fwd(g, myspline)
eval_fwd(eval_points, loc, kernel)
eval_fwd(g, loc, kernel)</code></pre><p>Construct a forward mapping matrix <code>E</code> by evaluating a basis or kernel at specific points.</p><p>This function has two main modes of operation:</p><ol><li><strong>B-spline Basis Evaluation</strong>: When given a <code>BSplineMethod</code>, it computes the matrix of  B-spline basis functions evaluated at each point in <code>eval_points</code>.</li><li><strong>RBF Kernel Evaluation</strong>: When given an <code>RBFKernelMethod</code>, it computes the Gram matrix  of kernel evaluations between each point in <code>eval_points</code> and each point in <code>loc</code>.</li></ol><p><strong>Arguments</strong></p><ul><li><code>eval_points::AbstractVector</code>: A vector of points at which to evaluate the basis/kernel.</li><li><code>g::Int</code>: An integer to create a regular grid of <code>g</code> evaluation points from 0 to 1.</li><li><code>myspline::BSplineMethod</code>: A B-spline object containing the order and knots.</li><li><code>loc::BlockVector</code>: A block vector of source locations for the RBF kernel.</li><li><code>kernel::RBFKernelMethod</code>: An RBF kernel object.</li></ul><p><strong>Returns</strong></p><ul><li><code>BlockMatrix</code>: A sparse block matrix representing the evaluation of the basis or kernel.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; myeval = range(0, 1; length=10);

julia&gt; knots = 0.0:0.2:1.0;

julia&gt; myspline = BSplineMethod(4, knots);

julia&gt; basis = BSplineBasis(BSplineOrder(order), knots);

julia&gt; E1 = eval_fwd(myeval, myspline);

julia&gt; E2 = eval_fwd(10, myspline);

julia&gt; E1 == E2
true

julia&gt; E1[1, 1] ≈ 1.0
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/HoYUN-stat/CovIterSolvers.jl/blob/5aadd3383822d88d6c6ca4458831e07c2b156e6e//src/blockevaluation.jl#L2-L46">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CovIterSolvers.fpca" href="#CovIterSolvers.fpca"><code>CovIterSolvers.fpca</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fpca(k, E, A, myspline)
fpca(k, E, A, K; itmax=50)</code></pre><p>Performs Functional Principal Component Analysis (FPCA) to find the evaluation of  leading <code>k</code> eigenfunctions and their corresponding eigenvalues.</p><p>This function solves the generalized eigenvalue problem <code>A*v = λ*G*v</code> or <code>A*v = λ*K*v</code> using one of two methods:</p><ol><li><strong>Direct B-spline Method</strong>: When provided with a <code>BSplineMethod</code>, it solves the problem  directly using a Cholesky and eigenvalue decomposition. This is suitable for smaller,  well-behaved systems where the Galerkin matrix <code>G</code> can be formed.</li><li><strong>Iterative Krylov Method</strong>: When provided with a covariance matrix <code>K</code>, it uses the  Conjugate Lanczos algorithm (<code>conj_lanczos</code>) to iteratively find the eigenvalues.  This is suitable for large, sparse, or matrix-free problems.</li></ol><p><strong>Arguments</strong></p><ul><li><code>k::Int</code>: The number of principal components to compute.</li><li><code>E::BlockMatrix</code>: The evaluation matrix that maps coefficients to function values.</li><li><code>A::BlockDiagonal</code>: A block-diagonal matrix representing the prior covariance of the coefficients (the <code>A</code> matrix in the eigenproblem).</li><li><code>myspline::BSplineMethod</code>: A B-spline method object defining the basis.</li><li><code>K::BlockMatrix</code>: A Gram matrix representing the inner product for the eigenproblem.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>itmax::Int=50</code>: (Iterative method only) The maximum number of iterations for the Lanczos algorithm.</li></ul><p><strong>Returns</strong></p><ul><li><code>Tuple{Vector, Matrix}</code>: A tuple containing:<ol><li>A vector of the <code>k</code> largest eigenvalues (PC variances).</li><li>A matrix whose columns are the corresponding <code>k</code> eigenfunctions (PC vectors).</li></ol></li></ul></div><a class="docs-sourcelink" target="_blank" href="github.com/HoYUN-stat/CovIterSolvers.jl/blob/5aadd3383822d88d6c6ca4458831e07c2b156e6e//src/blockfpca.jl#L2-L35">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CovIterSolvers.loc_grid-Tuple{Type{&lt;:Number}, Vector{Int64}}" href="#CovIterSolvers.loc_grid-Tuple{Type{&lt;:Number}, Vector{Int64}}"><code>CovIterSolvers.loc_grid</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">loc_grid([T=Float64], block_sizes; seed=nothing)</code></pre><p>Generate a <code>BlockVector</code> of random locations on the interval [0, 1).</p><p>This is useful for creating sample points for functional data, where each block represents the observation locations for a single function. Locations within each block are sorted for real-valued types.</p><p><strong>Arguments</strong></p><ul><li><code>T::Type{&lt;:Number}</code>: The element type of the locations. Defaults to <code>Float64</code>.</li><li><code>block_sizes::Vector{Int}</code>: A vector specifying the number of locations for each block.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>seed::Union{Nothing,Int}</code>: An optional seed for reproducibility.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; loc = loc_grid([3, 2]; seed=42);

julia&gt; blocklength(loc)
2

julia&gt; blocksizes(loc, 1)
[3, 2]

julia&gt; loc.blocks[1]
3-element Vector{Float64}:
 0.4503389405961936
 0.47740714343281776
 0.6293451231426089</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/HoYUN-stat/CovIterSolvers.jl/blob/5aadd3383822d88d6c6ca4458831e07c2b156e6e//src/blockforward.jl#L1-L33">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CovIterSolvers.mean_fwd-Union{Tuple{T}, Tuple{BlockArrays.BlockVector{T, R} where R&lt;:(AbstractVector{&lt;:AbstractVector{T}}), BSplineMethod{T}}} where T" href="#CovIterSolvers.mean_fwd-Union{Tuple{T}, Tuple{BlockArrays.BlockVector{T, R} where R&lt;:(AbstractVector{&lt;:AbstractVector{T}}), BSplineMethod{T}}} where T"><code>CovIterSolvers.mean_fwd</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mean_fwd(loc, myspline)</code></pre><p>Construct a forward mapping matrix <code>Φ</code> for a B-spline basis.</p><p>Each row of <code>Φ</code> corresponds to a location in <code>loc</code>, and each column corresponds to a B-spline basis function. The entry <code>Φ[i, j]</code> is the value of the j-th basis function evaluated at the i-th location.</p><p><strong>Arguments</strong></p><ul><li><code>loc::BlockVector{T}</code>: A block vector of locations.</li><li><code>myspline::BSplineMethod{T}</code>: A <code>BSplineMethod</code> object containing the B-spline order and knot vector.</li></ul><p><strong>Returns</strong></p><ul><li><code>BlockMatrix{T}</code>: A sparse block matrix representing the B-spline evaluation.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; knots = 0.0:0.2:1.0; # Simplified knots for a clear example

julia&gt; myspline = BSplineMethod(4, knots);

julia&gt; loc = loc_grid([2, 1]; seed=1);

julia&gt; Φ = mean_fwd(loc, myspline);

julia&gt; size(Φ)
(3, 8)

julia&gt; Φ[1, 3] ≈ 0.1565989814693208
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/HoYUN-stat/CovIterSolvers.jl/blob/5aadd3383822d88d6c6ca4458831e07c2b156e6e//src/blockforward.jl#L64-L97">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CovIterSolvers.mean_fwd-Union{Tuple{T}, Tuple{BlockArrays.BlockVector{T, R} where R&lt;:(AbstractVector{&lt;:AbstractVector{T}}), RBFKernelMethod{T}}} where T" href="#CovIterSolvers.mean_fwd-Union{Tuple{T}, Tuple{BlockArrays.BlockVector{T, R} where R&lt;:(AbstractVector{&lt;:AbstractVector{T}}), RBFKernelMethod{T}}} where T"><code>CovIterSolvers.mean_fwd</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mean_fwd(loc, kernel)</code></pre><p>Construct a Gram matrix <code>K</code> from an RBF kernel and a set of locations.</p><p>The entry <code>K[i, j]</code> is the value of the kernel evaluated at the distance between the i-th and j-th locations, i.e., <code>K[i, j] = kernel(||loc[i] - loc[j]||)</code>.</p><p><strong>Arguments</strong></p><ul><li><code>loc::BlockVector{T}</code>: A block vector of evaluation locations.</li><li><code>kernel::RBFKernelMethod{T}</code>: An RBF kernel object. If <code>kernel.trunc_dist</code> is set, the resulting matrix will be sparse.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; loc = loc_grid([2, 1]; seed=1);

julia&gt; kernel = GaussianKernel(50.0); # A kernel with high decay

julia&gt; K = mean_fwd(loc, kernel);

julia&gt; size(K)
(3, 3)

julia&gt; K[1, 2] ≈ 0.022251307501408822
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/HoYUN-stat/CovIterSolvers.jl/blob/5aadd3383822d88d6c6ca4458831e07c2b156e6e//src/blockforward.jl#L188-L215">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CovIterSolvers.rand_block_diag-Tuple{Type, Vector{Int64}}" href="#CovIterSolvers.rand_block_diag-Tuple{Type, Vector{Int64}}"><code>CovIterSolvers.rand_block_diag</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rand_block_diag([T=Float64], block_sizes; seed=nothing)</code></pre><p>Create a <code>BlockDiagonal</code> matrix with random elements.</p><p>The blocks are created as square matrices according to the specified sizes.</p><p><strong>Arguments</strong></p><ul><li><code>T::Type</code>: The element type of the blocks. Defaults to <code>Float64</code>.</li><li><code>block_sizes::Vector{Int}</code>: A vector of integers specifying the size of each square block.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>seed::Union{Nothing, Int}</code>: An integer seed for the random number generator to ensure reproducibility. Defaults to <code>nothing</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; block_sizes = [2, 1];

julia&gt; bd = rand_block_diag(block_sizes; seed=123);

julia&gt; bd.blocks[1]
2×2 Matrix{Float64}:
 0.521214  0.890879
 0.586807  0.190907</code></pre><p>See also <a href="#CovIterSolvers.zero_block_diag-Tuple{Type, Vector{Int64}}"><code>zero_block_diag</code></a>, <a href="#CovIterSolvers.undef_block_diag-Tuple{Type, Vector{Int64}}"><code>undef_block_diag</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/HoYUN-stat/CovIterSolvers.jl/blob/5aadd3383822d88d6c6ca4458831e07c2b156e6e//src/blockdiag.jl#L171-L199">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CovIterSolvers.sample_gp" href="#CovIterSolvers.sample_gp"><code>CovIterSolvers.sample_gp</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sample_gp([μ], process, loc; jitter=1e-6, seed=nothing)</code></pre><p>Generate one or more sample paths from a specified Gaussian Process.</p><p><strong>Arguments</strong></p><ul><li><code>μ::Function</code>: (Optional) A mean function <code>t -&gt; value</code>. Defaults to a zero mean.</li><li><code>process::AbstractBlockGP</code>: The Gaussian Process object defining the covariance.</li><li><code>loc::AbstractVector</code> or <code>AbstractBlockVector</code>: A vector or block vector of locations. If a <code>BlockVector</code> is provided, a separate sample path is generated for each block.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>jitter::Float64</code>: A small value added to the diagonal of the covariance matrix for numerical stability. Default is <code>1e-6</code>.</li><li><code>seed::Union{Nothing,Int}</code>: An integer seed for the random number generator to ensure reproducibility.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector</code> or <code>BlockVector</code>: The generated sample path(s), matching the type of <code>loc</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; loc = [0.1, 0.5, 0.9];

julia&gt; bm = BrownianMotion();

julia&gt; y = sample_gp(bm, loc; seed=123);

julia&gt; length(y)
3</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/HoYUN-stat/CovIterSolvers.jl/blob/5aadd3383822d88d6c6ca4458831e07c2b156e6e//src/blockgaussproc.jl#L188-L219">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CovIterSolvers.undef_block_diag-Tuple{Type, Vector{Int64}}" href="#CovIterSolvers.undef_block_diag-Tuple{Type, Vector{Int64}}"><code>CovIterSolvers.undef_block_diag</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">undef_block_diag([T=Float64], block_sizes)</code></pre><p>Create a <code>BlockDiagonal</code> matrix with uninitialized elements.</p><p>The blocks are created as square matrices according to the specified sizes.</p><p><strong>Arguments</strong></p><ul><li><code>T::Type</code>: The element type of the blocks. Defaults to <code>Float64</code>.</li><li><code>block_sizes::Vector{Int}</code>: A vector of integers specifying the size of each square block.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; block_sizes = [2, 3];

julia&gt; bd = undef_block_diag(UInt8, block_sizes);

julia&gt; eltype(bd)
UInt8

julia&gt; size(bd.blocks[1])
(2, 2)

julia&gt; size(bd.blocks[2])
(3, 3)</code></pre><p>See also <a href="#CovIterSolvers.zero_block_diag-Tuple{Type, Vector{Int64}}"><code>zero_block_diag</code></a>, <a href="#CovIterSolvers.rand_block_diag-Tuple{Type, Vector{Int64}}"><code>rand_block_diag</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/HoYUN-stat/CovIterSolvers.jl/blob/5aadd3383822d88d6c6ca4458831e07c2b156e6e//src/blockdiag.jl#L130-L158">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CovIterSolvers.zero_block_diag-Tuple{Type, Vector{Int64}}" href="#CovIterSolvers.zero_block_diag-Tuple{Type, Vector{Int64}}"><code>CovIterSolvers.zero_block_diag</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">zero_block_diag([T=Float64], block_sizes)</code></pre><p>Create a <code>BlockDiagonal</code> matrix with all elements set to zero.</p><p>The blocks are created as square matrices according to the specified sizes.</p><p><strong>Arguments</strong></p><ul><li><code>T::Type</code>: The element type of the blocks. Defaults to <code>Float64</code>.</li><li><code>block_sizes::Vector{Int}</code>: A vector of integers specifying the size of each square block.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; block_sizes = [2, 1];

julia&gt; bd = zero_block_diag(block_sizes);

julia&gt; eltype(bd)
Float64

julia&gt; bd.blocks[1]
2×2 Matrix{Float64}:
 0.0  0.0
 0.0  0.0</code></pre><p>See also <a href="#CovIterSolvers.undef_block_diag-Tuple{Type, Vector{Int64}}"><code>undef_block_diag</code></a>, <a href="#CovIterSolvers.rand_block_diag-Tuple{Type, Vector{Int64}}"><code>rand_block_diag</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/HoYUN-stat/CovIterSolvers.jl/blob/5aadd3383822d88d6c6ca4458831e07c2b156e6e//src/blockdiag.jl#L89-L117">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.12.0 on <span class="colophon-date" title="Wednesday 18 June 2025 16:09">Wednesday 18 June 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
