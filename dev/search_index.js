var documenterSearchIndex = {"docs":
[{"location":"api/structures/#Block-Structures","page":"Block Structures","title":"Block Structures","text":"","category":"section"},{"location":"api/structures/","page":"Block Structures","title":"Block Structures","text":"These types are used for representing block-structured data common in functional data analysis.","category":"page"},{"location":"api/structures/#CovIterSolvers.BlockDiagonal","page":"Block Structures","title":"CovIterSolvers.BlockDiagonal","text":"BlockDiagonal{T, R<:(AbstractArray{<:AbstractArray{T, 2}, 1})}\n\nBlocked array of square matrices of type T arranged in a block diagonal structure.\n\nFields\n\nblocks::R: stores the vector of matrices of type T being wrapped.\n\nSupertype Hierarchy\n\nBlockDiagonal{T, R<:(AbstractArray{<:AbstractArray{T, 2}, 1})} <: AbstractArray{T, 1} <: Any\n\nExamples\n\njulia> A = [1 2; 3 4];\n\njulia> B = [5 6; 8 9];\n\njulia> bd = BlockDiagonal([A, B]);\n\njulia> bd.blocks[1]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\nSee also blocksizes, zero_block_diag, undef_block_diag, rand_block_diag.\n\n\n\n\n\n","category":"type"},{"location":"api/structures/#CovIterSolvers.zero_block_diag","page":"Block Structures","title":"CovIterSolvers.zero_block_diag","text":"zero_block_diag([T=Float64], block_sizes)\n\nCreate a BlockDiagonal matrix with all elements set to zero.\n\nThe blocks are created as square matrices according to the specified sizes.\n\nArguments\n\nT::Type: The element type of the blocks. Defaults to Float64.\nblock_sizes::Vector{Int}: A vector of integers specifying the size of each square block.\n\nExamples\n\njulia> block_sizes = [2, 1];\n\njulia> bd = zero_block_diag(block_sizes);\n\njulia> eltype(bd)\nFloat64\n\njulia> bd.blocks[1]\n2×2 Matrix{Float64}:\n 0.0  0.0\n 0.0  0.0\n\nSee also undef_block_diag, rand_block_diag.\n\n\n\n\n\n","category":"function"},{"location":"api/structures/#CovIterSolvers.undef_block_diag","page":"Block Structures","title":"CovIterSolvers.undef_block_diag","text":"undef_block_diag([T=Float64], block_sizes)\n\nCreate a BlockDiagonal matrix with uninitialized elements.\n\nThe blocks are created as square matrices according to the specified sizes.\n\nArguments\n\nT::Type: The element type of the blocks. Defaults to Float64.\nblock_sizes::Vector{Int}: A vector of integers specifying the size of each square block.\n\nExamples\n\njulia> block_sizes = [2, 3];\n\njulia> bd = undef_block_diag(UInt8, block_sizes);\n\njulia> eltype(bd)\nUInt8\n\njulia> size(bd.blocks[1])\n(2, 2)\n\njulia> size(bd.blocks[2])\n(3, 3)\n\nSee also zero_block_diag, rand_block_diag.\n\n\n\n\n\n","category":"function"},{"location":"api/structures/#CovIterSolvers.rand_block_diag","page":"Block Structures","title":"CovIterSolvers.rand_block_diag","text":"rand_block_diag([T=Float64], block_sizes; seed=nothing)\n\nCreate a BlockDiagonal matrix with random elements.\n\nThe blocks are created as square matrices according to the specified sizes.\n\nArguments\n\nT::Type: The element type of the blocks. Defaults to Float64.\nblock_sizes::Vector{Int}: A vector of integers specifying the size of each square block.\n\nKeyword Arguments\n\nseed::Union{Nothing, Int}: An integer seed for the random number generator to ensure reproducibility. Defaults to nothing.\n\nExamples\n\njulia> block_sizes = [2, 1];\n\njulia> bd = rand_block_diag(block_sizes; seed=123);\n\njulia> bd.blocks[1]\n2×2 Matrix{Float64}:\n 0.521214  0.890879\n 0.586807  0.190907\n\nSee also zero_block_diag, undef_block_diag.\n\n\n\n\n\n","category":"function"},{"location":"api/structures/#CovIterSolvers.block_outer","page":"Block Structures","title":"CovIterSolvers.block_outer","text":"block_outer(y)\ny ⊙ y\n\nComputes the block-wise outer product of a BlockVector, returning a BlockDiagonal matrix.\n\nFor a BlockVector y with blocks y₁, y₂, ..., this function computes a BlockDiagonal matrix where the i-th block is the outer product yᵢ * yᵢ'.\n\nThe infix operator ⊙ is an alias for this function. It must be used on the same object (e.g., y ⊙ y).\n\nArguments\n\ny::AbstractBlockVector: The input block vector.\n\nExamples\n\njulia> v = [1.0, 2.0, 3.0];\n\njulia> y = BlockVector(v, [2, 1]);\n\njulia> (y ⊙ y).blocks[1]\n2×2 Matrix{Float64}:\n 1.0  2.0\n 2.0  4.0\n\n\n\n\n\n","category":"function"},{"location":"api/structures/#CovIterSolvers.:⊙","page":"Block Structures","title":"CovIterSolvers.:⊙","text":"y ⊙ y\n\nComputes the block-wise outer product of a BlockVector, returning a BlockDiagonal matrix.\n\nThe infix operator ⊙ is an alias for block_outer(y), and must be used on the same object (e.g., y ⊙ y).\n\nSee also block_outer. ```\n\n\n\n\n\nE ⊙ E\n\nThe infix operator ⊙ is an alias for the constructor BlockOuter(E). It requires that both operands are the same object (e.g., E ⊙ E).\n\nSee also BlockOuter.\n\n\n\n\n\n","category":"function"},{"location":"api/structures/#BlockArrays.blocksizes","page":"Block Structures","title":"BlockArrays.blocksizes","text":"blocksizes(D::BlockDiagonal, d::Int)\n\nReturns the sizes of the blocks in a BlockDiagonal matrix along the specified dimension d.\n\nArguments\n\nD::BlockDiagonal: The block diagonal matrix.\nd::Int: The dimension along which to get the block sizes (1 for rows, 2 for columns).\n\nExamples\n\njulia> block_sizes = [2, 1];\n\njulia> bd = rand_block_diag(block_sizes; seed=123);\n\njulia> blocksizes(bd, 1)\n2-element Vector{Int64}:\n 2\n 1\n\n\n\n\n\n","category":"function"},{"location":"api/structures/#CovIterSolvers.AbstractBlockTensor","page":"Block Structures","title":"CovIterSolvers.AbstractBlockTensor","text":"AbstractBlockTensor{T}\n\nElement-free tensor type for block-wise operations.\n\nSee also BlockOuter, CovFwdTensor, AdjointBlockOuter, and AdjointCovFwdTensor.\n\n\n\n\n\n","category":"type"},{"location":"api/structures/#CovIterSolvers.BlockOuter","page":"Block Structures","title":"CovIterSolvers.BlockOuter","text":"BlockOuter(E, [workspace])\nE ⊙ E\n\nRepresents a linear operator L that performs a block-wise outer product.\n\nThe operator L is defined by its action on a BlockDiagonal matrix A: B = L(A), where the j-th block of B is computed as B_j = ∑ᵢ Eⱼᵢ Aᵢ Eᵢⱼ'.\n\nThe infix operator ⊙ is an alias for the constructor BlockOuter(E). It requires that both operands are the same object (e.g., E ⊙ E).\n\nFields\n\nE::AbstractBlockMatrix: The block matrix that defines the operator.\nworkspace::Matrix: Pre-allocated matrix to be used for intermediate calculations.\n\nExamples\n\njulia> E = BlockMatrix(rand(3, 2), [2, 1], [1, 1]);\n\njulia> L = E ⊙ E; # Element-free operator\n\njulia> L_adj = L'; # Take the adjoint\n\njulia> L_adj isa AdjointBlockOuter\ntrue\n\nSee also AdjointBlockOuter.\n\n\n\n\n\n","category":"type"},{"location":"api/structures/#CovIterSolvers.AdjointBlockOuter","page":"Block Structures","title":"CovIterSolvers.AdjointBlockOuter","text":"AdjointBlockOuter(E, [workspace])\n\nRepresents the adjoint of the BlockOuter operator.\n\nThis type is typically not constructed directly, but rather by taking the adjoint of a BlockOuter object (e.g., L').\n\nThe operator L' is defined by its action on a BlockDiagonal matrix A: A = L'(B), where the i-th block of A is computed as A_i = ∑ⱼ Eⱼᵢ' Bⱼ Eᵢⱼ.\n\nFields\n\nF::AbstractBlockMatrix: The block matrix that defines the original operator.\nworkspace::Matrix: Pre-allocated matrix to be used for intermediate calculations.\n\nExamples\n\njulia> E = BlockMatrix(rand(3, 2), [2, 1], [1, 1]);\n\njulia> L_adj = (E ⊙ E)';\n\njulia> L_adj isa AdjointBlockOuter\ntrue\n\nSee also BlockOuter.\n\n\n\n\n\n","category":"type"},{"location":"api/structures/#CovIterSolvers.CovFwdTensor","page":"Block Structures","title":"CovIterSolvers.CovFwdTensor","text":"CovFwdTensor(F, [workspace])\n\nRepresents a covariance-based forward operator L for B-splines or RKHS.\n\nIts action L = O * (F ⊙ F) * O' depends on the block structure of F`.\n\nFields\n\nF::AbstractBlockMatrix: The block matrix that defines the core of the operator.\nworkspace::Matrix: Pre-allocated matrix to be used for intermediate calculations.\n\nExamples\n\njulia> F = BlockMatrix(rand(3, 2), [2, 1], [1, 1]);\n\njulia> L = CovFwdTensor(F);\n\njulia> L_adj = adjoint(L); # Or L'\n\njulia> L_adj isa AdjointCovFwdTensor\ntrue\n\nSee also AdjointCovFwdTensor.\n\n\n\n\n\n","category":"type"},{"location":"api/structures/#CovIterSolvers.AdjointCovFwdTensor","page":"Block Structures","title":"CovIterSolvers.AdjointCovFwdTensor","text":"AdjointCovFwdTensor(F, [workspace])\n\nRepresents the adjoint of the CovFwdTensor operator.\n\nFields\n\nF::AbstractBlockMatrix: The block matrix that defines the core of the operator.\nworkspace::Matrix: Pre-allocated matrix to be used for intermediate calculations.\n\nExamples\n\njulia> F = BlockMatrix(rand(3, 2), [2, 1], [1, 1]);\n\njulia> L = CovFwdTensor(F);\n\njulia> L_adj = L';\n\njulia> L_adj isa AdjointCovFwdTensor\ntrue\n\njulia> L_adj' === L\ntrue\n\nSee also CovFwdTensor.\n\n\n\n\n\n","category":"type"},{"location":"api/estimation/#Estimation-Methods","page":"Estimation Methods","title":"Estimation Methods","text":"","category":"section"},{"location":"api/estimation/","page":"Estimation Methods","title":"Estimation Methods","text":"These types and functions define the methods for covariance smoothing.","category":"page"},{"location":"api/estimation/#CovIterSolvers.AbstractEstimateMethod","page":"Estimation Methods","title":"CovIterSolvers.AbstractEstimateMethod","text":"AbstractEstimateMethod{T}\n\nSupertype for all estimation methods in this package.\n\nSubtypes\n\nBSplineMethod{T}: Methods based on B-splines.\nRBFKernelMethod{T}: Methods based on Radial Basis Functions (RBF) kernels.\n\n\n\n\n\n","category":"type"},{"location":"api/estimation/#CovIterSolvers.BSplineMethod","page":"Estimation Methods","title":"CovIterSolvers.BSplineMethod","text":"BSplineMethod(order, knots)\n\nAn estimation method that uses a B-spline basis.\n\nArguments\n\norder::Int: The order of the B-spline (e.g., 4 for cubic B-splines).\nknots::AbstractVector: The knot vector defining the B-spline basis.\n\nExamples\n\njulia> knots = 0.0:0.1:1.0;\n\njulia> method = BSplineMethod(4, knots);\n\njulia> method.order\n4\n\n\n\n\n\n","category":"type"},{"location":"api/estimation/#CovIterSolvers.RBFKernelMethod","page":"Estimation Methods","title":"CovIterSolvers.RBFKernelMethod","text":"RBFKernelMethod{T} <: AbstractEstimateMethod{T}\n\nAbstract supertype for methods based on a Radial Basis Function (RBF) kernel.\n\nAll RBF kernels define a function K(x, y) that depends only on the distance between x and y, i.e., K(x, y) = f(||x - y||).\n\nSee also GaussianKernel, LaplacianKernel, MaternKernel, CustomKernel for concrete implementations.\n\n\n\n\n\n","category":"type"},{"location":"api/estimation/#CovIterSolvers.GaussianKernel","page":"Estimation Methods","title":"CovIterSolvers.GaussianKernel","text":"GaussianKernel(γ, [trunc_dist=nothing])\n\nA Gaussian Radial Basis Function (RBF) kernel defined by K(x, y) = exp(-γ * ||x - y||^2).\n\nArguments\n\nγ::Real: The positive kernel parameter.\ntrunc_dist::Union{Nothing, Real}: An optional truncation distance. If provided, the kernel will return zero for ||x - y|| > trunc_dist.\n\nExamples\n\njulia> gk = GaussianKernel(0.5)\nGaussianKernel{Float64}(0.5, nothing)\n\njulia> gk_trunc = GaussianKernel(0.5, 10.0)\nGaussianKernel{Float64}(0.5, 10.0)\n\n\n\n\n\n","category":"type"},{"location":"api/estimation/#CovIterSolvers.LaplacianKernel","page":"Estimation Methods","title":"CovIterSolvers.LaplacianKernel","text":"LaplacianKernel(γ, [trunc_dist=nothing])\n\nA Laplacian Radial Basis Function (RBF) kernel defined by K(x, y) = exp(-γ * ||x - y||).\n\nArguments\n\nγ::Real: The positive kernel parameter.\ntrunc_dist::Union{Nothing, Real}: An optional truncation distance. If provided, the kernel will return zero for ||x - y|| > trunc_dist.\n\nExamples\n\njulia> lk = LaplacianKernel(0.5)\nLaplacianKernel{Float64}(0.5, nothing)\n\njulia> lk_trunc = LaplacianKernel(0.5, 10.0)\nLaplacianKernel{Float64}(0.5, 10.0)\n\n\n\n\n\n","category":"type"},{"location":"api/estimation/#CovIterSolvers.MaternKernel","page":"Estimation Methods","title":"CovIterSolvers.MaternKernel","text":"MaternKernel(ν, γ, [trunc_dist=nothing])\n\nA Matern Radial Basis Function (RBF) kernel defined by K(x, y) = (2^(1-ν) / Γ(ν)) * (γ * ||x - y||)^ν * K_{ν}(γ * ||x - y||), where K_{ν} is the modified Bessel function of the second kind.\n\nArguments\n\nν::Real: The smoothness parameter (ν = 1/2: Laplacian, ν → ∞: Gaussian).\nγ::Real: The positive kernel parameter.\ntrunc_dist::Union{Nothing, Real}: An optional truncation distance. If provided, the kernel will return zero for ||x - y|| > trunc_dist.\n\nExamples\n\njulia> mk = MaternKernel(1.5, 0.5)\nMaternKernel{Float64}(1.5, 0.5, nothing)\n\njulia> mk_trunc = MaternKernel(1.5, 0.5, 10.0)\nMaternKernel{Float64}(1.5, 0.5, 10.0)\n\n\n\n\n\n","category":"type"},{"location":"api/estimation/#CovIterSolvers.CustomKernel","page":"Estimation Methods","title":"CovIterSolvers.CustomKernel","text":"CustomKernel(f, [trunc_dist=nothing])\n\nA custom Radial Basis Function (RBF) kernel defined by a user-provided function f.\n\nThe kernel is defined as K(x, y) = f(||x - y||).\n\nArguments\n\nf::Function: A function that takes a distance of type T and returns a real number.\ntrunc_dist::Union{Nothing, T}: An optional truncation distance. If provided, the kernel will return zero for ||x - y|| > trunc_dist.\n\nExamples\n\njulia> f(x) = exp(-x^2);  # Example custom kernel function\n\njulia> ck = CustomKernel(f)\nCustomKernel{Float64,typeof(f)}(f, nothing)\n\njulia> ck_trunc = CustomKernel(f, 10.0)\nCustomKernel{Float64,typeof(f)}(f, 10.0)\n\n\n\n\n\n","category":"type"},{"location":"api/estimation/#CovIterSolvers.mean_fwd","page":"Estimation Methods","title":"CovIterSolvers.mean_fwd","text":"mean_fwd(loc, myspline)\n\nConstruct a forward mapping matrix Φ for a B-spline basis.\n\nEach row of Φ corresponds to a location in loc, and each column corresponds to a B-spline basis function. The entry Φ[i, j] is the value of the j-th basis function evaluated at the i-th location.\n\nArguments\n\nloc::BlockVector{T}: A block vector of locations.\nmyspline::BSplineMethod{T}: A BSplineMethod object containing the B-spline order and knot vector.\n\nReturns\n\nBlockMatrix{T}: A sparse block matrix representing the B-spline evaluation.\n\nExamples\n\njulia> knots = 0.0:0.2:1.0; # Simplified knots for a clear example\n\njulia> myspline = BSplineMethod(4, knots);\n\njulia> loc = loc_grid([2, 1]; seed=1);\n\njulia> Φ = mean_fwd(loc, myspline);\n\njulia> size(Φ)\n(3, 8)\n\njulia> Φ[1, 3] ≈ 0.1565989814693208\ntrue\n\n\n\n\n\nmean_fwd(loc, kernel)\n\nConstruct a Gram matrix K from an RBF kernel and a set of locations.\n\nThe entry K[i, j] is the value of the kernel evaluated at the distance between the i-th and j-th locations, i.e., K[i, j] = kernel(||loc[i] - loc[j]||).\n\nArguments\n\nloc::BlockVector{T}: A block vector of evaluation locations.\nkernel::RBFKernelMethod{T}: An RBF kernel object. If kernel.trunc_dist is set, the resulting matrix will be sparse.\n\nExamples\n\njulia> loc = loc_grid([2, 1]; seed=1);\n\njulia> kernel = GaussianKernel(50.0); # A kernel with high decay\n\njulia> K = mean_fwd(loc, kernel);\n\njulia> size(K)\n(3, 3)\n\njulia> K[1, 2] ≈ 0.022251307501408822\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/estimation/#CovIterSolvers.eval_fwd","page":"Estimation Methods","title":"CovIterSolvers.eval_fwd","text":"eval_fwd(eval_points, myspline)\neval_fwd(g, myspline)\neval_fwd(eval_points, loc, kernel)\neval_fwd(g, loc, kernel)\n\nConstruct a forward mapping matrix E by evaluating a basis or kernel at specific points.\n\nThis function has two main modes of operation:\n\nB-spline Basis Evaluation: When given a BSplineMethod, it computes the matrix of  B-spline basis functions evaluated at each point in eval_points.\nRBF Kernel Evaluation: When given an RBFKernelMethod, it computes the Gram matrix  of kernel evaluations between each point in eval_points and each point in loc.\n\nArguments\n\neval_points::AbstractVector: A vector of points at which to evaluate the basis/kernel.\ng::Int: An integer to create a regular grid of g evaluation points from 0 to 1.\nmyspline::BSplineMethod: A B-spline object containing the order and knots.\nloc::BlockVector: A block vector of source locations for the RBF kernel.\nkernel::RBFKernelMethod: An RBF kernel object.\n\nReturns\n\nBlockMatrix: A sparse block matrix representing the evaluation of the basis or kernel.\n\nExamples\n\njulia> myeval = range(0, 1; length=10);\n\njulia> knots = 0.0:0.2:1.0;\n\njulia> myspline = BSplineMethod(4, knots);\n\njulia> basis = BSplineBasis(BSplineOrder(order), knots);\n\njulia> E1 = eval_fwd(myeval, myspline);\n\njulia> E2 = eval_fwd(10, myspline);\n\njulia> E1 == E2\ntrue\n\njulia> E1[1, 1] ≈ 1.0\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/estimation/#CovIterSolvers.eval_covariance","page":"Estimation Methods","title":"CovIterSolvers.eval_covariance","text":"eval_covariance(E, A)\n\nComputes the covariance matrix Σ = E * A * E'.\n\nArguments\n\nE::BlockMatrix{T}: The forward evaluation matrix.\nA::BlockDiagonal{T}: A block-diagonal matrix, typically representing the prior covariance of the coefficients.\n\nReturns\n\nMatrix{T}: The resulting dense covariance matrix Σ.\n\nExamples\n\njulia> E = BlockMatrix(ones(3, 2), [3], [2]);\n\njulia> A = BlockDiagonal([[1.0 0.5; 0.5 1.0]]);\n\njulia> Σ = eval_covariance(E, A)\n3×3 Matrix{Float64}:\n 3.0  3.0  3.0\n 3.0  3.0  3.0\n 3.0  3.0  3.0\n\n\n\n\n\n","category":"function"},{"location":"api/estimation/#CovIterSolvers.compute_kernel","page":"Estimation Methods","title":"CovIterSolvers.compute_kernel","text":"compute_kernel(dist, kernel)\n\nCompute the value of an RBF kernel for a given distance.\n\nThis function uses multiple dispatch to select the correct kernel formula based on the type of the kernel object.\n\nArguments\n\ndist::Real: The distance between two points.\nkernel::RBFKernelMethod: The kernel object containing its parameters.\n\nReturns\n\nThe scalar value of the kernel evaluation.\n\nExamples\n\njulia> dist = 0.4;\n\njulia> kernel = GaussianKernel(1.0);\n\njulia> compute_kernel(dist, kernel) ≈ 0.8521437889662113\ntrue\n\n\n\n\n\n","category":"function"},{"location":"#CovIterSolvers.jl","page":"Home","title":"CovIterSolvers.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CovIterSolvers.jl provides a high-performance pipeline for covariance smoothing and functional principal component analysis using Krylov subspace methods.","category":"page"},{"location":"#API-Reference","page":"Home","title":"API Reference","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The following pages list all the functions and types available in the package.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"api/gaussian_processes/#Gaussian-Processes","page":"Gaussian Processes","title":"Gaussian Processes","text":"","category":"section"},{"location":"api/gaussian_processes/","page":"Gaussian Processes","title":"Gaussian Processes","text":"Types and functions for defining and sampling from Gaussian processes.","category":"page"},{"location":"api/gaussian_processes/#CovIterSolvers.AbstractBlockGP","page":"Gaussian Processes","title":"CovIterSolvers.AbstractBlockGP","text":"AbstractBlockGP{T}\n\nAbstract supertype for all Gaussian Process (GP), characterized by its covariance function.\n\n\n\n\n\n","category":"type"},{"location":"api/gaussian_processes/#CovIterSolvers.BrownianMotion","page":"Gaussian Processes","title":"CovIterSolvers.BrownianMotion","text":"BrownianMotion([T=Float64])\n\nA standard Brownian Motion / Wiener Process.\n\nThe covariance function is Σ(s, t) = min(s, t).\n\nExamples\n\njulia> bm = BrownianMotion();\n\njulia> covariancekernel(bm, 0.2, 0.5)\n0.2\n\n\n\n\n\n","category":"type"},{"location":"api/gaussian_processes/#CovIterSolvers.BrownianBridge","page":"Gaussian Processes","title":"CovIterSolvers.BrownianBridge","text":"BrownianBridge([T=Float64])\n\nA standard Brownian Bridge process, which is a Brownian Motion conditioned to be zero at t=0 and t=1.\n\nThe covariance function is Σ(s, t) = min(s, t) - s * t.\n\nExamples\n\njulia> bb = BrownianBridge();\n\njulia> covariancekernel(bb, 0.2, 0.5)\n0.1\n\n\n\n\n\n","category":"type"},{"location":"api/gaussian_processes/#CovIterSolvers.IntegratedBM","page":"Gaussian Processes","title":"CovIterSolvers.IntegratedBM","text":"IntegratedBM([T=Float64])\n\nAn Integrated Brownian Motion process.\n\nThe covariance function is Σ(s, t) = max(s,t) * min(s,t)^2 / 2 - min(s,t)^3 / 6.\n\nExamples\n\njulia> ibm = IntegratedBM();\n\njulia> covariancekernel(ibm, 0.2, 0.5)\n0.008666666666666668\n\n\n\n\n\n","category":"type"},{"location":"api/gaussian_processes/#CovIterSolvers.OrnsteinUhlenbeck","page":"Gaussian Processes","title":"CovIterSolvers.OrnsteinUhlenbeck","text":"OrnsteinUhlenbeck(θ, σ)\n\nAn Ornstein-Uhlenbeck process, which models a mean-reverting stochastic process.\n\nThe covariance function is Σ(s, t) = (σ²/2θ) * (exp(-θ|s-t|) - exp(-θ(s+t))).\n\nArguments\n\nθ::Real: The mean reversion rate (must be positive).\nσ::Real: The volatility parameter (must be non-negative).\n\nExamples\n\njulia> ou = OrnsteinUhlenbeck(1.0, 0.5);\n\njulia> ou.θ\n1.0\n\n\n\n\n\n","category":"type"},{"location":"api/gaussian_processes/#CovIterSolvers.CustomGP","page":"Gaussian Processes","title":"CovIterSolvers.CustomGP","text":"CustomGP([T=Float64], Σ)\n\nA Gaussian Process defined by a user-supplied covariance function Σ(s, t).\n\nArguments\n\nT::Type: The element type of the process. Defaults to Float64.\nΣ::Function: A two-argument function (s, t) -> value that defines the covariance.\n\nExamples\n\njulia> my_cov(s, t) = exp(-abs(s - t)); # Exponential covariance\n\njulia> gp = CustomGP(my_cov);\n\njulia> covariancekernel(gp, 0.2, 0.5) ≈ exp(-0.3)\ntrue\n\n\n\n\n\n","category":"type"},{"location":"api/gaussian_processes/#CovIterSolvers.loc_grid","page":"Gaussian Processes","title":"CovIterSolvers.loc_grid","text":"loc_grid([T=Float64], block_sizes; seed=nothing)\n\nGenerate a BlockVector of random locations on the interval [0, 1).\n\nThis is useful for creating sample points for functional data, where each block represents the observation locations for a single function. Locations within each block are sorted for real-valued types.\n\nArguments\n\nT::Type{<:Number}: The element type of the locations. Defaults to Float64.\nblock_sizes::Vector{Int}: A vector specifying the number of locations for each block.\n\nKeyword Arguments\n\nseed::Union{Nothing,Int}: An optional seed for reproducibility.\n\nExamples\n\njulia> loc = loc_grid([3, 2]; seed=42);\n\njulia> blocklength(loc)\n2\n\njulia> blocksizes(loc, 1)\n[3, 2]\n\njulia> loc.blocks[1]\n3-element Vector{Float64}:\n 0.4503389405961936\n 0.47740714343281776\n 0.6293451231426089\n\n\n\n\n\n","category":"function"},{"location":"api/gaussian_processes/#CovIterSolvers.covariancekernel","page":"Gaussian Processes","title":"CovIterSolvers.covariancekernel","text":"covariancekernel(process, s, t)\ncovariancekernel(process, s)\ncovariancekernel(process, loc1, loc2)\ncovariancekernel(process, loc)\n\nCompute the covariance for a given Gaussian Process.\n\nThis function has several methods:\n\ncovariancekernel(process, s, t): Computes the scalar covariance between two points s and t.\ncovariancekernel(process, s): Computes the covariance of a single point s with itself.\ncovariancekernel(process, loc1, loc2): Computes the cross-covariance matrix between two vectors of locations.\ncovariancekernel(process, loc): Computes the full covariance matrix (Gram matrix) for a single vector of locations.\n\nArguments\n\nprocess::AbstractBlockGP: The Gaussian Process object defining the covariance structure.\ns, t::Number: Scalar locations.\nloc1, loc2, loc::AbstractVector: Vectors of locations.\n\nExamples\n\njulia> bm = BrownianMotion();\n\njulia> covariancekernel(bm, 0.3, 0.8) # scalar version\n0.3\n\njulia> loc = [0.1, 0.5, 0.9];\n\njulia> K = covariancekernel(bm, loc) # matrix version\n3×3 Matrix{Float64}:\n 0.1  0.1  0.1\n 0.1  0.5  0.5\n 0.1  0.5  0.9\n\nSee also sample_gp for generating sample paths from the GP.\n\n\n\n\n\n","category":"function"},{"location":"api/gaussian_processes/#CovIterSolvers.sample_gp","page":"Gaussian Processes","title":"CovIterSolvers.sample_gp","text":"sample_gp([μ], process, loc; jitter=1e-6, seed=nothing)\n\nGenerate one or more sample paths from a specified Gaussian Process.\n\nArguments\n\nμ::Function: (Optional) A mean function t -> value. Defaults to a zero mean.\nprocess::AbstractBlockGP: The Gaussian Process object defining the covariance.\nloc::AbstractVector or AbstractBlockVector: A vector or block vector of locations. If a BlockVector is provided, a separate sample path is generated for each block.\n\nKeyword Arguments\n\njitter::Float64: A small value added to the diagonal of the covariance matrix for numerical stability. Default is 1e-6.\nseed::Union{Nothing,Int}: An integer seed for the random number generator to ensure reproducibility.\n\nReturns\n\nVector or BlockVector: The generated sample path(s), matching the type of loc.\n\nExamples\n\njulia> loc = [0.1, 0.5, 0.9];\n\njulia> bm = BrownianMotion();\n\njulia> y = sample_gp(bm, loc; seed=123);\n\njulia> length(y)\n3\n\n\n\n\n\n","category":"function"},{"location":"api/solvers/#Solvers-and-FPCA","page":"Solvers & FPCA","title":"Solvers and FPCA","text":"","category":"section"},{"location":"api/solvers/","page":"Solvers & FPCA","title":"Solvers & FPCA","text":"Functions for solving linear systems and performing functional principal component analysis.","category":"page"},{"location":"api/solvers/#CovIterSolvers.conj_lanczos","page":"Solvers & FPCA","title":"CovIterSolvers.conj_lanczos","text":"conj_lanczos(b0, D, C; ...)\n\nPerforms the C-Lanczos algorithm for the generalized eigenvalue problem D*C*q = λ*q.\n\nThis iterative method generates a C-orthonormal basis Q for the Krylov subspace and a symmetric tridiagonal matrix T that represents the projection of the operator D*C onto that subspace.\n\nArguments\n\nb0::AbstractBlockVector{T}: The starting vector for the iteration.\nD::BlockDiagonal{T}: A block-diagonal matrix to factorize.\nC::AbstractBlockMatrix{T}: A symmetric, positive-definite matrix defining the inner product (C-inner product).\n\nKeyword Arguments\n\nitmax::Int=100: Maximum number of iterations.\ntol::Float64=1e-8: Tolerance for the C-norm of the residual to determine convergence.\nhistory::Bool=false: If true, the history of residual C-norms is stored and returned.\nreortho_level::Symbol=:full: Level of reorthogonalization. Use :full for numerical stability, or :none to observe loss of orthogonality.\n\nReturns\n\nNamedTuple: A named tuple (T, Q, history) containing:\nT: A SymTridiagonal matrix.\nQ: A matrix whose columns are the C-orthonormal Lanczos basis vectors.\nhistory: A vector of residual C-norms, or nothing if history=false.\n\n\n\n\n\n","category":"function"},{"location":"api/solvers/#CovIterSolvers.fpca","page":"Solvers & FPCA","title":"CovIterSolvers.fpca","text":"fpca(k, E, A, myspline)\nfpca(k, E, A, K; itmax=50)\n\nPerforms Functional Principal Component Analysis (FPCA) to find the evaluation of  leading k eigenfunctions and their corresponding eigenvalues.\n\nThis function solves the generalized eigenvalue problem A*v = λ*G*v or A*v = λ*K*v using one of two methods:\n\nDirect B-spline Method: When provided with a BSplineMethod, it solves the problem  directly using a Cholesky and eigenvalue decomposition. This is suitable for smaller,  well-behaved systems where the Galerkin matrix G can be formed.\nIterative Krylov Method: When provided with a covariance matrix K, it uses the  Conjugate Lanczos algorithm (conj_lanczos) to iteratively find the eigenvalues.  This is suitable for large, sparse, or matrix-free problems.\n\nArguments\n\nk::Int: The number of principal components to compute.\nE::BlockMatrix: The evaluation matrix that maps coefficients to function values.\nA::BlockDiagonal: A block-diagonal matrix representing the prior covariance of the coefficients (the A matrix in the eigenproblem).\nmyspline::BSplineMethod: A B-spline method object defining the basis.\nK::BlockMatrix: A Gram matrix representing the inner product for the eigenproblem.\n\nKeyword Arguments\n\nitmax::Int=50: (Iterative method only) The maximum number of iterations for the Lanczos algorithm.\n\nReturns\n\nTuple{Vector, Matrix}: A tuple containing:\nA vector of the k largest eigenvalues (PC variances).\nA matrix whose columns are the corresponding k eigenfunctions (PC vectors).\n\n\n\n\n\n","category":"function"}]
}
