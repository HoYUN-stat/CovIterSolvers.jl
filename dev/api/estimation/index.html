<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Estimation Methods · CovIterSolvers.jl</title><meta name="title" content="Estimation Methods · CovIterSolvers.jl"/><meta property="og:title" content="Estimation Methods · CovIterSolvers.jl"/><meta property="twitter:title" content="Estimation Methods · CovIterSolvers.jl"/><meta name="description" content="Documentation for CovIterSolvers.jl."/><meta property="og:description" content="Documentation for CovIterSolvers.jl."/><meta property="twitter:description" content="Documentation for CovIterSolvers.jl."/><meta property="og:url" content="https://HoYUN-stat.github.io/CovIterSolvers.jl/api/estimation/"/><meta property="twitter:url" content="https://HoYUN-stat.github.io/CovIterSolvers.jl/api/estimation/"/><link rel="canonical" href="https://HoYUN-stat.github.io/CovIterSolvers.jl/api/estimation/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">CovIterSolvers.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="../structures/">Block Structures</a></li><li><a class="tocitem" href="../gaussian_processes/">Gaussian Processes</a></li><li class="is-active"><a class="tocitem" href>Estimation Methods</a></li><li><a class="tocitem" href="../solvers/">Solvers &amp; FPCA</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API</a></li><li class="is-active"><a href>Estimation Methods</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Estimation Methods</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="github.com/HoYUN-stat/CovIterSolvers.jl/blob/main//docs/src/api/estimation.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Estimation-Methods"><a class="docs-heading-anchor" href="#Estimation-Methods">Estimation Methods</a><a id="Estimation-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Estimation-Methods" title="Permalink"></a></h1><p>These types and functions define the methods for covariance smoothing.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CovIterSolvers.AbstractEstimateMethod" href="#CovIterSolvers.AbstractEstimateMethod"><code>CovIterSolvers.AbstractEstimateMethod</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractEstimateMethod{T}</code></pre><p>Supertype for all estimation methods in this package.</p><p><strong>Subtypes</strong></p><ul><li><code>BSplineMethod{T}</code>: Methods based on B-splines.</li><li><code>RBFKernelMethod{T}</code>: Methods based on Radial Basis Functions (RBF) kernels.</li></ul></div><a class="docs-sourcelink" target="_blank" href="github.com/HoYUN-stat/CovIterSolvers.jl/blob/fb845ef5a163b71e2e0e5ead91ce1c6bd5eae8bf//src/estimationmethod.jl#L1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CovIterSolvers.BSplineMethod" href="#CovIterSolvers.BSplineMethod"><code>CovIterSolvers.BSplineMethod</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BSplineMethod(order, knots)</code></pre><p>An estimation method that uses a B-spline basis.</p><p><strong>Arguments</strong></p><ul><li><code>order::Int</code>: The order of the B-spline (e.g., 4 for cubic B-splines).</li><li><code>knots::AbstractVector</code>: The knot vector defining the B-spline basis.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; knots = 0.0:0.1:1.0;

julia&gt; method = BSplineMethod(4, knots);

julia&gt; method.order
4</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/HoYUN-stat/CovIterSolvers.jl/blob/fb845ef5a163b71e2e0e5ead91ce1c6bd5eae8bf//src/estimationmethod.jl#L28-L46">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CovIterSolvers.RBFKernelMethod" href="#CovIterSolvers.RBFKernelMethod"><code>CovIterSolvers.RBFKernelMethod</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RBFKernelMethod{T} &lt;: AbstractEstimateMethod{T}</code></pre><p>Abstract supertype for methods based on a Radial Basis Function (RBF) kernel.</p><p>All RBF kernels define a function <code>K(x, y)</code> that depends only on the distance between <code>x</code> and <code>y</code>, i.e., <code>K(x, y) = f(||x - y||)</code>.</p><p>See also <a href="#CovIterSolvers.GaussianKernel"><code>GaussianKernel</code></a>, <a href="#CovIterSolvers.LaplacianKernel"><code>LaplacianKernel</code></a>, <a href="#CovIterSolvers.MaternKernel"><code>MaternKernel</code></a>, <a href="#CovIterSolvers.CustomKernel"><code>CustomKernel</code></a> for concrete implementations.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/HoYUN-stat/CovIterSolvers.jl/blob/fb845ef5a163b71e2e0e5ead91ce1c6bd5eae8bf//src/estimationmethod.jl#L12-L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CovIterSolvers.GaussianKernel" href="#CovIterSolvers.GaussianKernel"><code>CovIterSolvers.GaussianKernel</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">GaussianKernel(γ, [trunc_dist=nothing])</code></pre><p>A Gaussian Radial Basis Function (RBF) kernel defined by <code>K(x, y) = exp(-γ * ||x - y||^2)</code>.</p><p><strong>Arguments</strong></p><ul><li><code>γ::Real</code>: The positive kernel parameter.</li><li><code>trunc_dist::Union{Nothing, Real}</code>: An optional truncation distance. If provided, the kernel will return zero for <code>||x - y|| &gt; trunc_dist</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; gk = GaussianKernel(0.5)
GaussianKernel{Float64}(0.5, nothing)

julia&gt; gk_trunc = GaussianKernel(0.5, 10.0)
GaussianKernel{Float64}(0.5, 10.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/HoYUN-stat/CovIterSolvers.jl/blob/fb845ef5a163b71e2e0e5ead91ce1c6bd5eae8bf//src/estimationmethod.jl#L52-L70">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CovIterSolvers.LaplacianKernel" href="#CovIterSolvers.LaplacianKernel"><code>CovIterSolvers.LaplacianKernel</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LaplacianKernel(γ, [trunc_dist=nothing])</code></pre><p>A Laplacian Radial Basis Function (RBF) kernel defined by <code>K(x, y) = exp(-γ * ||x - y||)</code>.</p><p><strong>Arguments</strong></p><ul><li><code>γ::Real</code>: The positive kernel parameter.</li><li><code>trunc_dist::Union{Nothing, Real}</code>: An optional truncation distance. If provided, the kernel will return zero for <code>||x - y|| &gt; trunc_dist</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; lk = LaplacianKernel(0.5)
LaplacianKernel{Float64}(0.5, nothing)

julia&gt; lk_trunc = LaplacianKernel(0.5, 10.0)
LaplacianKernel{Float64}(0.5, 10.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/HoYUN-stat/CovIterSolvers.jl/blob/fb845ef5a163b71e2e0e5ead91ce1c6bd5eae8bf//src/estimationmethod.jl#L82-L100">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CovIterSolvers.MaternKernel" href="#CovIterSolvers.MaternKernel"><code>CovIterSolvers.MaternKernel</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MaternKernel(ν, γ, [trunc_dist=nothing])</code></pre><p>A Matern Radial Basis Function (RBF) kernel defined by <code>K(x, y) = (2^(1-ν) / Γ(ν)) * (γ * ||x - y||)^ν * K_{ν}(γ * ||x - y||)</code>, where <code>K_{ν}</code> is the modified Bessel function of the second kind.</p><p><strong>Arguments</strong></p><ul><li><code>ν::Real</code>: The smoothness parameter (ν = 1/2: Laplacian, ν → ∞: Gaussian).</li><li><code>γ::Real</code>: The positive kernel parameter.</li><li><code>trunc_dist::Union{Nothing, Real}</code>: An optional truncation distance. If provided, the kernel will return zero for <code>||x - y|| &gt; trunc_dist</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; mk = MaternKernel(1.5, 0.5)
MaternKernel{Float64}(1.5, 0.5, nothing)

julia&gt; mk_trunc = MaternKernel(1.5, 0.5, 10.0)
MaternKernel{Float64}(1.5, 0.5, 10.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/HoYUN-stat/CovIterSolvers.jl/blob/fb845ef5a163b71e2e0e5ead91ce1c6bd5eae8bf//src/estimationmethod.jl#L112-L133">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CovIterSolvers.CustomKernel" href="#CovIterSolvers.CustomKernel"><code>CovIterSolvers.CustomKernel</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CustomKernel(f, [trunc_dist=nothing])</code></pre><p>A custom Radial Basis Function (RBF) kernel defined by a user-provided function <code>f</code>.</p><p>The kernel is defined as <code>K(x, y) = f(||x - y||)</code>.</p><p><strong>Arguments</strong></p><ul><li><code>f::Function</code>: A function that takes a distance of type <code>T</code> and returns a real number.</li><li><code>trunc_dist::Union{Nothing, T}</code>: An optional truncation distance. If provided, the kernel will return zero for <code>||x - y|| &gt; trunc_dist</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; f(x) = exp(-x^2);  # Example custom kernel function

julia&gt; ck = CustomKernel(f)
CustomKernel{Float64,typeof(f)}(f, nothing)

julia&gt; ck_trunc = CustomKernel(f, 10.0)
CustomKernel{Float64,typeof(f)}(f, 10.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/HoYUN-stat/CovIterSolvers.jl/blob/fb845ef5a163b71e2e0e5ead91ce1c6bd5eae8bf//src/estimationmethod.jl#L146-L168">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CovIterSolvers.mean_fwd" href="#CovIterSolvers.mean_fwd"><code>CovIterSolvers.mean_fwd</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mean_fwd(loc, myspline)</code></pre><p>Construct a forward mapping matrix <code>Φ</code> for a B-spline basis.</p><p>Each row of <code>Φ</code> corresponds to a location in <code>loc</code>, and each column corresponds to a B-spline basis function. The entry <code>Φ[i, j]</code> is the value of the j-th basis function evaluated at the i-th location.</p><p><strong>Arguments</strong></p><ul><li><code>loc::BlockVector{T}</code>: A block vector of locations.</li><li><code>myspline::BSplineMethod{T}</code>: A <code>BSplineMethod</code> object containing the B-spline order and knot vector.</li></ul><p><strong>Returns</strong></p><ul><li><code>BlockMatrix{T}</code>: A sparse block matrix representing the B-spline evaluation.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; knots = 0.0:0.2:1.0; # Simplified knots for a clear example

julia&gt; myspline = BSplineMethod(4, knots);

julia&gt; loc = loc_grid([2, 1]; seed=1);

julia&gt; Φ = mean_fwd(loc, myspline);

julia&gt; size(Φ)
(3, 8)

julia&gt; Φ[1, 3] ≈ 0.1565989814693208
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/HoYUN-stat/CovIterSolvers.jl/blob/fb845ef5a163b71e2e0e5ead91ce1c6bd5eae8bf//src/blockforward.jl#L64-L97">source</a></section><section><div><pre><code class="language-julia hljs">mean_fwd(loc, kernel)</code></pre><p>Construct a Gram matrix <code>K</code> from an RBF kernel and a set of locations.</p><p>The entry <code>K[i, j]</code> is the value of the kernel evaluated at the distance between the i-th and j-th locations, i.e., <code>K[i, j] = kernel(||loc[i] - loc[j]||)</code>.</p><p><strong>Arguments</strong></p><ul><li><code>loc::BlockVector{T}</code>: A block vector of evaluation locations.</li><li><code>kernel::RBFKernelMethod{T}</code>: An RBF kernel object. If <code>kernel.trunc_dist</code> is set, the resulting matrix will be sparse.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; loc = loc_grid([2, 1]; seed=1);

julia&gt; kernel = GaussianKernel(50.0); # A kernel with high decay

julia&gt; K = mean_fwd(loc, kernel);

julia&gt; size(K)
(3, 3)

julia&gt; K[1, 2] ≈ 0.022251307501408822
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/HoYUN-stat/CovIterSolvers.jl/blob/fb845ef5a163b71e2e0e5ead91ce1c6bd5eae8bf//src/blockforward.jl#L188-L215">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CovIterSolvers.eval_fwd" href="#CovIterSolvers.eval_fwd"><code>CovIterSolvers.eval_fwd</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">eval_fwd(eval_points, myspline)
eval_fwd(g, myspline)
eval_fwd(eval_points, loc, kernel)
eval_fwd(g, loc, kernel)</code></pre><p>Construct a forward mapping matrix <code>E</code> by evaluating a basis or kernel at specific points.</p><p>This function has two main modes of operation:</p><ol><li><strong>B-spline Basis Evaluation</strong>: When given a <code>BSplineMethod</code>, it computes the matrix of  B-spline basis functions evaluated at each point in <code>eval_points</code>.</li><li><strong>RBF Kernel Evaluation</strong>: When given an <code>RBFKernelMethod</code>, it computes the Gram matrix  of kernel evaluations between each point in <code>eval_points</code> and each point in <code>loc</code>.</li></ol><p><strong>Arguments</strong></p><ul><li><code>eval_points::AbstractVector</code>: A vector of points at which to evaluate the basis/kernel.</li><li><code>g::Int</code>: An integer to create a regular grid of <code>g</code> evaluation points from 0 to 1.</li><li><code>myspline::BSplineMethod</code>: A B-spline object containing the order and knots.</li><li><code>loc::BlockVector</code>: A block vector of source locations for the RBF kernel.</li><li><code>kernel::RBFKernelMethod</code>: An RBF kernel object.</li></ul><p><strong>Returns</strong></p><ul><li><code>BlockMatrix</code>: A sparse block matrix representing the evaluation of the basis or kernel.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; myeval = range(0, 1; length=10);

julia&gt; knots = 0.0:0.2:1.0;

julia&gt; myspline = BSplineMethod(4, knots);

julia&gt; basis = BSplineBasis(BSplineOrder(order), knots);

julia&gt; E1 = eval_fwd(myeval, myspline);

julia&gt; E2 = eval_fwd(10, myspline);

julia&gt; E1 == E2
true

julia&gt; E1[1, 1] ≈ 1.0
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/HoYUN-stat/CovIterSolvers.jl/blob/fb845ef5a163b71e2e0e5ead91ce1c6bd5eae8bf//src/blockevaluation.jl#L2-L46">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CovIterSolvers.eval_covariance" href="#CovIterSolvers.eval_covariance"><code>CovIterSolvers.eval_covariance</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">eval_covariance(E, A)</code></pre><p>Computes the covariance matrix <code>Σ = E * A * E&#39;</code>.</p><p><strong>Arguments</strong></p><ul><li><code>E::BlockMatrix{T}</code>: The forward evaluation matrix.</li><li><code>A::BlockDiagonal{T}</code>: A block-diagonal matrix, typically representing the prior covariance of the coefficients.</li></ul><p><strong>Returns</strong></p><ul><li><code>Matrix{T}</code>: The resulting dense covariance matrix <code>Σ</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; E = BlockMatrix(ones(3, 2), [3], [2]);

julia&gt; A = BlockDiagonal([[1.0 0.5; 0.5 1.0]]);

julia&gt; Σ = eval_covariance(E, A)
3×3 Matrix{Float64}:
 3.0  3.0  3.0
 3.0  3.0  3.0
 3.0  3.0  3.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/HoYUN-stat/CovIterSolvers.jl/blob/fb845ef5a163b71e2e0e5ead91ce1c6bd5eae8bf//src/blockevaluation.jl#L140-L165">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CovIterSolvers.compute_kernel" href="#CovIterSolvers.compute_kernel"><code>CovIterSolvers.compute_kernel</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">compute_kernel(dist, kernel)</code></pre><p>Compute the value of an RBF kernel for a given distance.</p><p>This function uses multiple dispatch to select the correct kernel formula based on the type of the <code>kernel</code> object.</p><p><strong>Arguments</strong></p><ul><li><code>dist::Real</code>: The distance between two points.</li><li><code>kernel::RBFKernelMethod</code>: The kernel object containing its parameters.</li></ul><p><strong>Returns</strong></p><ul><li>The scalar value of the kernel evaluation.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; dist = 0.4;

julia&gt; kernel = GaussianKernel(1.0);

julia&gt; compute_kernel(dist, kernel) ≈ 0.8521437889662113
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/HoYUN-stat/CovIterSolvers.jl/blob/fb845ef5a163b71e2e0e5ead91ce1c6bd5eae8bf//src/blockforward.jl#L137-L161">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../gaussian_processes/">« Gaussian Processes</a><a class="docs-footer-nextpage" href="../solvers/">Solvers &amp; FPCA »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.13.0 on <span class="colophon-date" title="Thursday 19 June 2025 20:39">Thursday 19 June 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
